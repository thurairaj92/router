	Code Overview
	-------------
	For this phase of the assignment, most of the development is concentrated on sr_router.c file. This file has one major function which is sr_handlepacket and other helper functions to create ehternet, ip and icmp packets in order to eliminate code duplication. The sr_handlepacket function divided into two big if statements. One part handles ARP packets and the other part handles IP packets. 

	In ARP packets part, we take neccesary actions based on whether the packet is ARP Request or ARP Reply. In the case of ARP Request, the router just send a ARP Reply packet if the packet meant for the router with its MAC address which obtained through of sr_get_ip_interface function. If the ARP packet is a reply, then we bring back all the IP packets that were waiting for that particular MAC addresses. After receiving the MAC address, we send those IP packets which are encapsulated in ethernet packet with the received MAC Address. In both the request and reply case, if the packet isn't for router then we drop the packet. 

	In IP packet part, we have multiple things to cover which involve ICMP and not ICMP packets and packet for router and packet for other hosts. First, we validate the received IP packet by checking the checksum, header length and TTL, then the IP part is divided into two sections where one section will handle IP packets for router and the other part handles forwarding of the packet. If the IP packet is for the router, we check whether it is UDP/TCP packet or ICMP packet using IP protocol. If UDP/TCP we send type 3, code 3 ICMP packet and if it is ICMP echo packet we send type 0 ICMP packet. However, before sending the packets we check in ARP cache whether we have MAC address for the IP destination. If we have it, then we get the MAC address and if we don't have MAC address for the IP in cache, then we send a ARP request. We also queue the packet we want to send using sr_arpcache_queuereq function. We wait till ARP reply to process those packets. 

	If the IP is not for the router, then we first check rtable whether the IP is present in our routing table and if the router can't find the IP prefix through longest matching prefix, the packet we received then we send type 3 code 1 ICMP packet. If we could find in rtable, then we follow the same process about sending ICMP packets where we look in ARP cache or send ARP request for MAC address. However, before doing that, we decrement the TTL of the IP packet we received and check for TTL 0 error again. 

	As mentioned about, when we could find the MAC address we send a ARP request, handle_arpreq function handles this process. We first check whether the same request has been send out more than 4 times. If so, we need to process the IP packets which are waiting for ARP reply. We send type 3 code 1 ICMP packet to the source address of those IP packets(again using the same process as sending any other IP packets). Functions create_arp_header, create_ethernet_header, create_ip_header, create_icmp_header as name suggest create respective headers and packets. 


	Design Decisions and Assumptions 
	--------------------------------
	We had to make few design decisions and assumptions for this phase. We give 64 as initial TTL. Since this is very small network, we think 64 is good enough TTL for packets to get to intended host. We also did create unique id for IP packets, this is because id is only useful during fragmentation and de-fragmentation process and this phase is not focusing on that part. We also created a new struct to handle ICMP type 11. This is just maintain unique format of ICMP type 11. We also assumed that we should drop any packets that doesn't have proper checksum.  